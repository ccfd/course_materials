<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>Work Hard</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet"
      href="site_libs/highlight/default.css"
      type="text/css" />
<script src="site_libs/highlight/highlight.js"></script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>

<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script src="site_libs/navigation-1.0/tabsets.js"></script>
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">My Website</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="about.html">About</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Work Hard</h1>
<h4 class="author"><em>Łukasz Łaniewski</em></h4>
<h4 class="author"><em>Wojtek Gryglas</em></h4>

</div>


<p>This tutorial will try to teach you how to make and use a new model in TCLB. First it will discuss our goal: the model we want to create. Then it will take you step by step, on how to create all the needed components.</p>
<div id="finite-difference-wave-equation" class="section level2">
<h2>Finite Difference Wave equation</h2>
<p>We want to discretize the <a href="https://en.wikipedia.org/wiki/Wave_equation">Wave Equation</a>:</p>
<p><span class="math inline">\(\ddot u=c^2\Delta u\)</span></p>
<p>For this purpose we will use Finite Difference method. First we change the equation into two first order (in time) equations:</p>
<p><span class="math inline">\(\begin{cases}\dot v &amp;= c^2 \Delta u\\ \dot u &amp;= v\end{cases}\)</span></p>
<p>Now let us discretise the <a href="https://en.wikipedia.org/wiki/Laplace_operator">Laplace operator</a> with simple finite difference (in 2D):</p>
<div class="figure">
<embed src="https://latex.codecogs.com/gif.latex?%5CDelta%20u%20%5Csimeq%20%5Cfrac%7Bu_%7Bi-1%2Cj%7D&amp;plus;u_%7Bi&amp;plus;1%2Cj%7D&amp;plus;u_%7Bi%2Cj-1%7D&amp;plus;u_%7Bi%2Cj&amp;plus;1%7D-4%20u_%7Bi%2Cj%7D%7D%7Bdx%5E2%7D" />
<p class="caption">Delta u = (u(i-1)+u(i+1)-2u(i))/(dx^2)</p>
</div>
<p>Finnaly we will use, what is called <a href="https://en.wikipedia.org/wiki/Semi-implicit_Euler_method">Semi-implicit Euler rule</a> to integrate this equation in time. This will give us:</p>
<div class="figure">
<embed src="https://latex.codecogs.com/gif.latex?%5Cbegin%7Bcases%7Dv%5E%7Bn&amp;plus;1%7D_%7Bi%2Cj%7D%20%26%3D%20v%5En_%7Bi%2Cj%7D%20&amp;plus;%20%5Ctext%7Bdt%7D%5Ccdot%20c%5E2%20%5CDelta%20u%5En%5C%5Cu%5E%7Bn&amp;plus;1%7D_%7Bi%2Cj%7D%20%26%3D%20u%5En_%7Bi%2Cj%7D%20&amp;plus;%20%5Ctext%7Bdt%7D%5Ccdot%20v%5E%7Bn&amp;plus;1%7D_%7Bi%2Cj%7D%5Cend%7Bcases%7D" />
<p class="caption">v(n+1)=v(n)+dt c^2 Delta u(n), u(n+1)=u(n)+dt v(n+1)</p>
</div>
<p>The semi-implicit-ness can be seen in the index of <code>v</code> in the second line</p>
<p>Finnaly: we will get rid of all units by assuming <code>dx</code> and <code>dt</code> equal to 1</p>
</div>
<div id="implementation" class="section level1">
<h1>Implementation</h1>
<div id="creating-a-model" class="section level2">
<h2>Creating a model</h2>
<p>Every model in TCLB is defined by a subdirectory of <code>src</code>. Let us now create a new one:</p>
<pre class="bash"><code>mkdir src/wave
touch src/wave/conf.mk</code></pre>
<p>The <code>conf.mk</code> file stores some additional settings for a model, but it also tells TCLB that this directory is in fact a model.</p>
<p>Now we have to add two main files defining everything: <code>Dynamics.R</code> - defining all the setup of the model, and <code>Dynamics.c</code> - defining what will be happening in a node.</p>
<p>We want to have two [[Fields]]: <code>u</code> and <code>v</code>. So we define them in <code>Dynamics.R</code>:</p>
<pre class="r"><code>AddField(name=&quot;u&quot;)
AddField(name=&quot;v&quot;)</code></pre>
<p>Then we need the main dynamics of a node. First let us create a model that doesn’t do anything:</p>
<pre class="c"><code>CudaDeviceFunction float2 Color() {
  float2 ret;
  ret.x = 0;
  ret.y = 1;
  return ret;
}

CudaDeviceFunction void Init() { }

CudaDeviceFunction void Run() { }</code></pre>
<p>The <code>CudaDeviceFunction</code> prefix is needed for all functions in <code>Dynamics.c</code> for technical reasons. As you can see we needed to fill only the <code>Color</code> function, as it is the only one which returns a value. For now, the model doesn’t make sense. Let us first understand what these function do:</p>
<table style="width:94%;">
<colgroup>
<col width="29%" />
<col width="65%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>Init</code></td>
<td align="left">This function is called in all the nodes at the beginning of the simulation. All the initialization have to happen here</td>
</tr>
<tr class="even">
<td align="left"><code>Run</code></td>
<td align="left">This function will be called in every node in every iteration - it is the main dynamic of a node</td>
</tr>
<tr class="odd">
<td align="left"><code>Color</code></td>
<td align="left">This function is useful only for the version of CLB with enabled graphics. It calculates the level <code>x</code> on which the color of a pixel will be based. In most cases this will be temperature or velocity.</td>
</tr>
</tbody>
</table>
</div>
<div id="first-dynamics" class="section level2">
<h2>First dynamics</h2>
<p>First, we want to initialize our fields:</p>
<pre class="c"><code>CudaDeviceFunction void Init() {
  u = 0;
  v = 0;
}</code></pre>
<p>Then let us start with a model that just preserves both fields without changing them. In TCLB we access fields with a notation <code>u(dx,dy)</code>, where <code>dx</code> and <code>dy</code> is the position from which to take the field, relative to the current node:</p>
<pre class="c"><code>CudaDeviceFunction void Run() {
  u = u(0,0);
  v = v(0,0);
}</code></pre>
</div>
<div id="adding-quantities" class="section level2">
<h2>Adding [[Quantities]]</h2>
<p>Finally we want to access the resulting data. In TCLB, the data that will be exported to VTK, TXT or other format, are called [[Quantities]]. Let us add a quantity <code>U</code> to <code>Dynamics.R</code>:</p>
<pre class="r"><code>AddQuantity(name=&quot;U&quot;)</code></pre>
<p>Now we have to add the calculation:</p>
<pre class="c"><code>CudaDeviceFunction real_t getU() {
  return u(0,0);
}</code></pre>
</div>
<div id="running-a-case" class="section level2">
<h2>Running a case</h2>
<p>Now we can run a case (let’s call it <code>example.xml</code>):</p>
<pre class="xml"><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;CLBConfig output=&quot;output/&quot;&gt;
        &lt;Geometry nx=&quot;128&quot; ny=&quot;128&quot;&gt;
    &lt;/Geometry&gt;
    &lt;Model&gt;
    &lt;/Model&gt;
    &lt;VTK Iterations=&quot;10&quot;/&gt;
    &lt;Solve Iterations=&quot;1000&quot;/&gt;
&lt;/CLBConfig&gt;</code></pre>
<p>This case will create a mesh of 128x128 nodes, initialize it and run 1000 iterations. It will also save VTK output every 10 iterations.</p>
<p>The results are not so impressive now, because basically, not only nothing is happening in a node, but also it is initialized with 0.</p>
</div>
<div id="settings" class="section level2">
<h2>[[Settings]]</h2>
<p>Let us introduce two <a href="Settings">settings</a> to our model:</p>
<pre class="r"><code>AddSetting(name=&quot;Speed&quot;)
AddSetting(name=&quot;Value&quot;, zonal=TRUE)</code></pre>
<p>Where <code>Speed</code> will be our parameter <code>k</code> in the wave equation, and <code>Value</code> will be the initial value of <code>u</code>. [[Settings]] which we want to be changing in the domain, are called “zonal”. Settings are provided to us as variables in Dynamics.c:</p>
<pre class="c"><code>CudaDeviceFunction void Init() {
  u = Value;
  v = 0;
}</code></pre>
<p>Now we can name a region in our domain, and initialize it with a different value:</p>
<pre class="xml"><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;CLBConfig output=&quot;output/&quot;&gt;
        &lt;Geometry nx=&quot;128&quot; ny=&quot;128&quot;&gt;
                &lt;None name=&quot;box&quot;&gt;
                        &lt;Box dx=&quot;60&quot; nx=&quot;20&quot; dy=&quot;20&quot; ny=&quot;30&quot;/&gt;
                &lt;/None&gt;
    &lt;/Geometry&gt;
    &lt;Model&gt;
                &lt;Params Value=&quot;-1&quot;/&gt;
                &lt;Params Value-box=&quot;1&quot;/&gt;
    &lt;/Model&gt;
    &lt;VTK Iterations=&quot;10&quot;/&gt;
    &lt;Solve Iterations=&quot;1000&quot;/&gt;
&lt;/CLBConfig&gt;</code></pre>
<p>This will mark a box 20x30 starting from the point (60,20) as a zone called ‘box’. Then in the [[<code>&lt;Model/&gt;</code>|Container#model]] we first set <code>Value</code> in all zones to <code>-1</code>, then set it to <code>1</code> in ‘box’.</p>
<p>You will see that the results now are much more interesting. Ok. I’m joking, they are sill constant - but at least not 0.</p>
</div>
<div id="introducing-fd" class="section level2">
<h2>Introducing FD</h2>
<p>Now we want to introduce the discretisation of our wave equation in to the mix:</p>
<pre class="c"><code>CudaDeviceFunction void Run() {
  real_t lap_u = u(-1,0) + u(1,0) + u(0,-1) + u(0,1) - 4*u(0,0);
  real_t a = Speed * Speed * lap_u;
  v = v(0,0) + a;
  u = u(0,0) + v;
}</code></pre>
<p>You can see that we assumed <code>dx</code> and <code>dt</code> equal to 1 (it will be more clear why, later on).</p>
<p>And now … <strong>it won’t compile</strong>. Why? The error is a bit obscure, like with many C++ Templates errors, but the reason is simple. We didn’t tell the code that we want to access <code>u</code> in our neighbors. This is crucial, because the code have to know exactly were things are accessed, to prepare the right communication buffers. You can imagine that the neighboring node is on a different GPU on a different computer. Then we need this computer to know that it will have to send this data to us. On the other hand we want to send as small packets of information as possible, that why the code have to be <em>conservative</em> wrt. to the possible access patterns. We define this information in <code>Dynamics.R</code>:</p>
<pre class="r"><code>AddField(name=&quot;u&quot;, dx=c(-1,1), dy=c(-1,1))</code></pre>
<p>If you don’t know <a href="https://www.google.pl/?#q=r">R</a> then you need to know that <code>c(...)</code> means a vector/table of numbers. The above line means that the field <code>u</code> can be accessed for <code>dx</code> from -1 to 1 and <code>dy</code> from -1 to 1. Making it simple: we can access it from all of our 8 neighbors and ourselves. The other way (a shortcut) to express it would be:</p>
<pre class="r"><code>AddField(name=&quot;u&quot;, stencil2d=1)</code></pre>
<p>Which means the same thing (<code>stencil3d</code> would mean also -1 to 1 in <code>z</code> direction)</p>
<p>Now, the code compiles. We can add another</p>
<pre class="xml"><code>&lt;Params Speed=&quot;0.01&quot; /&gt;</code></pre>
<p>to our case file, run and see how the wave propagates.</p>
</div>
<div id="make-it-nicer" class="section level2">
<h2>Make it nicer:</h2>
<p>We see that the result isn’t very beautiful. It is partly because of our discretization, partly because the <a href="https://en.wikipedia.org/wiki/Sinc_function">Fourier transform of a rectangle</a> isn’t very nice. Let us introduce viscosity/drag to the system:</p>
<pre class="c"><code>CudaDeviceFunction void Run() {
  real_t lap_u = u(-1,0) + u(1,0) + u(0,-1) + u(0,1) - 4*u(0,0);
  real_t lap_v = v(-1,0) + v(1,0) + v(0,-1) + v(0,1) - 4*v(0,0);
  real_t a = Speed * Speed * lap_u + Viscosity * lap_v;
  v = v(0,0) + a;
  u = u(0,0) + v;
}</code></pre>
<p><strong>Remember:</strong> you have to modify the <code>v</code> field access pattern, and add a <code>Viscosity</code> setting in <code>Dynamics.R</code>.</p>
<p>Now you can play a bit with the settings to see some nice waves propagating. It can be seen now more clearly that <strong>the domain in TCLB is always periodic</strong>. That is simply because it is the most general case. If you want to make your domain non-periodic - you add boundary conditions - otherwise, whatever leaves on one side - gets back on the other.</p>
</div>
<div id="node-types" class="section level2">
<h2>Node types</h2>
<p>Now we can add <a href="https://github.com/CFD-GO/TCLB/wiki/Geometry">node types</a> that will change the behavior of some, selected nodes. For instance, let us have a Dirichlet boundary condition. We want the nodes that are on the boundary to set <code>u</code> and <code>v</code> to a fixed value. Let’s call such nodes <code>Dirichlet</code>. We define a new node type (yes, you guessed: in <code>Dynamics.R</code>):</p>
<pre class="r"><code>AddNodeType(name=&quot;Dirichlet&quot;, group=&quot;BOUNDARY&quot;)</code></pre>
<p>You can notice that node types have ‘groups’ (note: these groups, customary are with all caps). A node can have only one type … from each group. You can imagine it like this: in each node we want to be able to set <em>separately</em> a boundary condition, choose a discretization model and add a heat source. But you cannot set <em>two</em> boundary conditions in the same node.</p>
<p>Now, when we have this node type, we can use it to change the dynamics:</p>
<pre class="c"><code>CudaDeviceFunction void Run() {
  real_t lap_u = u(-1,0) + u(1,0) + u(0,-1) + u(0,1) - 4*u(0,0)
  real_t lap_v = v(-1,0) + v(1,0) + v(0,-1) + v(0,1) - 4*v(0,0)
  real_t a = Speed * Speed * lap_u + Viscosity * lap_v;
  v = v(0,0) + a;
  u = u(0,0) + v;
  if (NodeType == NODE_Dirichlet) {
    u = Value;
    v = 0;
  }
}</code></pre>
<p>You can notice that we re-used the same zonal setting <code>Value</code> in this boundary condition. You can also notice, that the main calculation is still executed in the Dirichlet nodes. You can test it and see which version runs faster. Such additional computation can sometimes have a favorable impact on the performance on GPU, because of thing called <a href="http://stackoverflow.com/questions/17223640/is-branch-divergence-really-so-bad">branching</a>.</p>
<p>Now, we can set some Dirichlet elements in the case file:</p>
<pre class="xml"><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;CLBConfig output=&quot;output/&quot;&gt;
        &lt;Geometry nx=&quot;128&quot; ny=&quot;128&quot;&gt;
                &lt;Dirichlet name=&quot;border&quot;&gt;
                        &lt;Box nx=&quot;1&quot;/&gt;
                        &lt;Box dx=&quot;-1&quot;/&gt;
                        &lt;Box ny=&quot;1&quot;/&gt;
                        &lt;Box dy=&quot;-1&quot;/&gt;
                &lt;/Dirichlet&gt;
                &lt;None name=&quot;box&quot;&gt;
                        &lt;Box dx=&quot;60&quot; nx=&quot;20&quot; dy=&quot;20&quot; ny=&quot;30&quot;/&gt;
                &lt;/None&gt;
    &lt;/Geometry&gt;
    &lt;Model&gt;
                &lt;Params Value=&quot;-1&quot;/&gt;
                &lt;Params Value-box=&quot;1&quot;/&gt;
                &lt;Params Value-border=&quot;-1&quot;/&gt;
                &lt;Params Speed=&quot;0.001&quot;/&gt;
                &lt;Params Viscosity=&quot;0.001&quot;/&gt;
    &lt;/Model&gt;
    &lt;VTK Iterations=&quot;10&quot;/&gt;
    &lt;Solve Iterations=&quot;1000&quot;/&gt;
&lt;/CLBConfig&gt;</code></pre>
<p>We can notice the difference immediately. The waves are bouncing from the walls now.</p>
<p>To understand the geometry definition, you have to imagine that <a href="Geometry-Primitive#box"><code>box</code></a> element by default spans the whole available space. Then by imposing <code>dx</code>, <code>nx</code> and <code>fx</code> attributes you cut it smaller. <code>dx</code> sets where the box starts, <code>nx</code> sets how <em>long</em> is the box in the x direction, and <code>fx</code> sets where it ends. Additionally, if you set a negative value it means a value <em>from the end</em>. The same applies of course to <code>y</code> and <code>z</code>. For example:</p>
<table style="width:94%;">
<colgroup>
<col width="36%" />
<col width="58%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Element</th>
<th align="left">Region</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>&lt;Box nx=&quot;1&quot;/&gt;</code></td>
<td align="left">Left border of the domain</td>
</tr>
<tr class="even">
<td align="left"><code>&lt;Box dx=&quot;-1&quot;/&gt;</code></td>
<td align="left">Right border of the domain</td>
</tr>
<tr class="odd">
<td align="left"><code>&lt;Box dx=&quot;10&quot;/&gt;</code></td>
<td align="left">Everything starting from the 11th element (in x direction)</td>
</tr>
<tr class="even">
<td align="left"><code>&lt;Box dx=&quot;-10&quot;/&gt;</code></td>
<td align="left">10 last layers in the x direction</td>
</tr>
<tr class="odd">
<td align="left"><code>&lt;Box nx=&quot;10&quot; ny=&quot;10&quot;/&gt;</code></td>
<td align="left">Square 10x10 in the left bottom corner</td>
</tr>
</tbody>
</table>
<p>In this case, we had a simple situation, as we have only one group of node types (and only one type), but normally we would have to distinguish between them. It would be done with:</p>
<pre class="c"><code>if ((NodeType &amp; NODE_BOUNDARY) == NODE_Dirichlet) {
 ...
}</code></pre>
<p>or</p>
<pre class="c"><code>switch (NodeType &amp; NODE_BOUNDARY) {
case NODE_Dirichlet:
 ...
 break;
case ...:
 ...
}</code></pre>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
